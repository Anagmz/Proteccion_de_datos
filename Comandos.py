# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oE_oar5u_RRBI6j562m1zoTkeRSvMR9-

Ejercicio 1
"""

n = 3 # número entero
address = "221b Baker Street, NW1 6XE, London" # Sherlock Holmes DIRECCIÓN
employee = {
     'age': 45,
     'role': 'CTO',
     'SSN': 'AB1234567',

     }
# vamos a imprimirlos
n

address

employee

"""Ejercicio 2"""

#bicicleta.py
# definamos la clase Bike
class Bike:
  def __init__(self, colour, frame_material):
    self.colour = colour
    self.frame_material = frame_material
  def brake(self):
    print("Braking!")
    # creemos un par de instancias
red_bike = Bike('Red', 'Carbon fiber')
blue_bike = Bike('Blue', 'Steel')
# inspeccionemos los objetos que tenemos, instancias de la clase Bike.
print(red_bike.colour) # impresiones: Rojo
print(red_bike.frame_material) # impresiones: fibra de carbono
print(blue_bike.colour) # impresiones: Azul
print(blue_bike.frame_material) # impresiones: Acero
red_bike.brake() # imprimimos Braking

"""Ejercicio 3"""

a = dict(A=1, Z=-1)
b = {'A': 1, 'Z': -1}
c = dict(zip(['A', 'Z'], [1, -1]))
d = dict([('A', 1), ('Z', -1)])
e = dict({'Z': -1, 'A': 1})
a == b == c == d == e # todos son iguales?

list(zip(['h', 'e', 'l', 'l', 'o'], [1, 2, 3, 4, 5]))

list(zip('hello', range(1, 6)))

vision = (9.5, 8.8)
vision

vision[0]

vision[1]

from collections import namedtuple
Vision = namedtuple('Vision', ['left', 'right'])
vision = Vision(9.5, 8.8)
vision[0]

vision.left

vision.right

Vision = namedtuple('Vision', ['left', 'combined', 'right'])
vision = Vision(9.5, 9.2, 8.8)
vision.left

vision.right

vision.combined

"""Ejercicio 4"""

from math import factorial
factorial(5)

factorial(10)

"""Ejercicio 5"""

int(True)  # Verdadero se comporta como 1

int(False)  # False se comporta como 0

bool(1) # 1 se evalúa como Verdadero en un contexto booleano

bool(-42)
# y también lo hace cada número distinto de cero Verdadero

bool(0)# 0 se evalúa como Falso

not True  # vistazo rápido a los operadores (and, or, not)

not False

True and True

False or True

1 + True

False + 42

7 - True

"""Ejercicio 6"""

# se usa la sintaxis user y password
user = 'heinrich'
password = 'super-secret'


# se imprimen
f"Log in with: {user} and {password}"

f"Log in with: {user=} and {password=}"

"""Ejercicio 7"""

#Se utilizan las variables a y b con su respectivo valor
a = 1000000
b = 1000000
id(a) == id(b)

# al igual que el anterior se le asigna un nuevo valor a las variables
a = 5
b = 5
id(a) == id(b)

"""Ejercicio 8"""

# Local, envolvente y global
def enclosing_func():
  m = 13

  def local():
# m no pertenece al alcance definido por el local
# función para que Python siga investigando la siguiente
# alcance adjunto. Esta vez m se encuentra en el recinto.
# alcance
      print(m, 'printing from the local scope')
# llamando a la función local
  local()
m = 5
print(m, 'printing from the global scope')
enclosing_func()

"""Ejercicio 9"""

age = 42
age

age = 43
age

age = 42
id(age)

age = 43
id(age)

"""Ejercicio 10"""

bytearray() #objeto bytearray vacío

bytearray(10) # instancia llena de ceros con una longitud determinada

bytearray(range(5)) # bytearray de iterable de enteros

name = bytearray(b'Lina') #A - matriz de bytes de bytes
name.replace(b'L', b'l')

name.count(b'L')

name.endswith(b'na')